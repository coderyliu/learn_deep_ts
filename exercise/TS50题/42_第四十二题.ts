// *实现一个 Permutation 工具类型，当输入一个联合类型时，返回一个包含该联合类型的全排列类型数组。具体的使用示例如下所示：
// 1. 通过extends语法来对T类型中的或值的每一个值进行遍历
// 如果不理解的可以参考下面的例子:
type TTT = ["a" | "b"] extends ["a"] | ["b"] ? true : false; // true
// 2. 遍历之后再对后续递归需要使用的K进行遍历(主要是起到排除当前T中的key的效果)
// 同时我们也知道, n个不重复值全排列的值为n的阶乘
// 也就是说我们需要在遍历的时候一直排除当前值, 遍历剩余值即可
// K extends K则是对当前递归场景下的所有key的遍历
// 然后最后, 递归处理剩余的参数即可, 期间使用了扩展运算符来对多维数组进行摊平
// 例如: 对于 'a' | 'b' | 'c' 来说, 会这样产生值
// ['a', ...['b', ...['c']]], ['a', ...['c', ...['b']]] ...
// 完成解构之后, 便成为了期望的  ['a', 'b', 'c'], ['a', 'c', 'b'] ...
type Permutation<T, K = T> = [T] extends [never]
  ? []
  : K extends K
  ? [K, ...Permutation<Exclude<T, K>>]
  : never;

// ["a", "b"] | ["b", "a"]
type P0 = Permutation<"a" | "b">; // ['a', 'b'] | ['b' | 'a']
// type P1 = ["a", "b", "c"] | ["a", "c", "b"] | ["b", "a", "c"]
// | ["b", "c", "a"] | ["c", "a", "b"] | ["c", "b", "a"]
type P1 = Permutation<"a" | "b" | "c">;

export {};
